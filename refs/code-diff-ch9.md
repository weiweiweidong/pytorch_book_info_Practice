#### ch9_cnn.ipynb  の差分

( 行頭が「-」: 削除された行、行頭が「+」:追加された行)

```
@@ -484,17 +484,23 @@
         "    base_epochs = len(history)\n",
         "  \n",
         "    for epoch in range(base_epochs, num_epochs+base_epochs):\n",
-        "        train_loss = 0\n",
-        "        train_acc = 0\n",
-        "        val_loss = 0\n",
-        "        val_acc = 0\n",
+        "        # 1エポックあたりの正解数(精度計算用)\n",
+        "        n_train_acc, n_val_acc = 0, 0\n",
+        "        # 1エポックあたりの累積損失(平均化前)\n",
+        "        train_loss, val_loss = 0, 0\n",
+        "        # 1エポックあたりのデータ累積件数\n",
+        "        n_train, n_test = 0, 0\n",
         "\n",
         "        #訓練フェーズ\n",
         "        net.train()\n",
-        "        count = 0\n",
         "\n",
         "        for inputs, labels in tqdm(train_loader):\n",
-        "            count += len(labels)\n",
+        "            # 1バッチあたりのデータ件数\n",
+        "            train_batch_size = len(labels)\n",
+        "            # 1エポックあたりのデータ累積件数\n",
+        "            n_train += train_batch_size\n",
+        "    \n",
+        "            # GPUヘ転送\n",
         "            inputs = inputs.to(device)\n",
         "            labels = labels.to(device)\n",
         "\n",
@@ -506,7 +512,6 @@
         "\n",
         "            # 損失計算\n",
         "            loss = criterion(outputs, labels)\n",
-        "            train_loss += loss.item()\n",
         "\n",
         "            # 勾配計算\n",
         "            loss.backward()\n",
@@ -514,44 +519,51 @@
         "            # パラメータ修正\n",
         "            optimizer.step()\n",
         "\n",
-        "            # 予測値算出\n",
+        "            # 予測ラベル導出\n",
         "            predicted = torch.max(outputs, 1)[1]\n",
         "\n",
-        "            # 正解件数算出\n",
-        "            train_acc += (predicted == labels).sum().item()\n",
-        "\n",
-        "            # 損失と精度の計算\n",
-        "            avg_train_loss = train_loss / count\n",
-        "            avg_train_acc = train_acc / count\n",
+        "            # 平均前の損失と正解数の計算\n",
+        "            # lossは平均計算が行われているので平均前の損失に戻して加算\n",
+        "            train_loss += loss.item() * train_batch_size \n",
+        "            n_train_acc += (predicted == labels).sum().item() \n",
         "\n",
         "        #予測フェーズ\n",
         "        net.eval()\n",
-        "        count = 0\n",
         "\n",
-        "        for inputs, labels in test_loader:\n",
-        "            count += len(labels)\n",
-        "            inputs = inputs.to(device)\n",
-        "            labels = labels.to(device)\n",
+        "        for inputs_test, labels_test in test_loader:\n",
+        "            # 1バッチあたりのデータ件数\n",
+        "            test_batch_size = len(labels_test)\n",
+        "            # 1エポックあたりのデータ累積件数\n",
+        "            n_test += test_batch_size\n",
+        "\n",
+        "            # GPUヘ転送\n",
+        "            inputs_test = inputs_test.to(device)\n",
+        "            labels_test = labels_test.to(device)\n",
         "\n",
         "            # 予測計算\n",
-        "            outputs = net(inputs)\n",
+        "            outputs_test = net(inputs_test)\n",
         "\n",
         "            # 損失計算\n",
-        "            loss = criterion(outputs, labels)\n",
-        "            val_loss += loss.item()\n",
-        "\n",
-        "            # 予測値算出\n",
-        "            predicted = torch.max(outputs, 1)[1]\n",
-        "\n",
-        "            # 正解件数算出\n",
-        "            val_acc += (predicted == labels).sum().item()\n",
-        "\n",
-        "            # 損失と精度の計算\n",
-        "            avg_val_loss = val_loss / count\n",
-        "            avg_val_acc = val_acc / count\n",
-        "    \n",
-        "        print (f'Epoch [{(epoch+1)}/{num_epochs+base_epochs}], loss: {avg_train_loss:.5f} acc: {avg_train_acc:.5f} val_loss: {avg_val_loss:.5f}, val_acc: {avg_val_acc:.5f}')\n",
-        "        item = np.array([epoch+1, avg_train_loss, avg_train_acc, avg_val_loss, avg_val_acc])\n",
+        "            loss_test = criterion(outputs_test, labels_test)\n",
+        " \n",
+        "            # 予測ラベル導出\n",
+        "            predicted_test = torch.max(outputs_test, 1)[1]\n",
+        "\n",
+        "            #  平均前の損失と正解数の計算\n",
+        "            # lossは平均計算が行われているので平均前の損失に戻して加算\n",
+        "            val_loss +=  loss_test.item() * test_batch_size\n",
+        "            n_val_acc +=  (predicted_test == labels_test).sum().item()\n",
+        "\n",
+        "        # 精度計算\n",
+        "        train_acc = n_train_acc / n_train\n",
+        "        val_acc = n_val_acc / n_test\n",
+        "        # 損失計算\n",
+        "        avg_train_loss = train_loss / n_train\n",
+        "        avg_val_loss = val_loss / n_test\n",
+        "        # 結果表示\n",
+        "        print (f'Epoch [{(epoch+1)}/{num_epochs+base_epochs}], loss: {avg_train_loss:.5f} acc: {train_acc:.5f} val_loss: {avg_val_loss:.5f}, val_acc: {val_acc:.5f}')\n",
+        "        # 記録\n",
+        "        item = np.array([epoch+1, avg_train_loss, train_acc, avg_val_loss, val_acc])\n",
         "        history = np.vstack((history, item))\n",
         "    return history"
       ],
```
